# My First Echo Server - writeup

This challenge is a "simple" one, in that the obvious vulnerability is that format strings are user controlled. There is a loop that gives us three opportunities to provide inputs that are passed as the first argument to `printf`. What is not obvious is how to exploit this, given that the executable has full RELRO, canary, NX bit, PIE, and all that annoying stuff, and the server has ASLR enabled. Despite these challenges, we will attempt to gain remote code execution through ret2libc below.

## Step 0 - How printf works

When passing a string to printf, it looks for `%` signs and interprets them in fancy ways.

```
%d
```

The `d` specifier means to treat the argument as a decimal number and print that instead of the literal `%d`.

Other specifiers such as `%s` for reading a string at the address specified by the argument, and `%x` for printing the hexadecimal value of an argument are also useful.

There are also subspecifiers. A number will cause the value to be padded.

```
%10s
```

Padding to width 10, given a strign `hi` will result in `        hi` (8 spaces, then hi). This is useful to ensuring we have a certain width of characters.

The `$` subspecifier tells printf to go to a particular argument. This is not supported in all implementations of printf (it is not standard). Nevertheless it is useful. Say you want to print the second argument as a hexadecimal. You could do

```
%x %x
```

which will print the first argument as hexadecimal, then the second. But maybe we do not want the first argument? So we can simply do

```
%2$x
```

Also, recall that arguments are stored in a few registers first and then on the stack in [64-bit calling conventions in Linux](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI). `printf` kindly makes assumptions about arguments being explicitly passed to it whenever it sees a valid format specifier (`%<something>`) and reads arguments even if they were not intended as arguments. With this all out of the way, let's get into abusing this application and owning it :)

## Step 1 - Get the PIE offset (bypass position independent executable)

Thanks to radare, when debugging an executable you can see the memory map addresses with the `dm` command. Unfortunately, you will see this constantly changes as ASLR causes PIE to choose a different offset every time. Luckily, the last 3 nibbles (nibbles = half bytes = hexadecimal characters) are always `000`. Furthermore, addresses relative to this offset are on the stack, and even in the `rcx` register which is treated as the fourth argument to functions. Our first payload then becomes

```
%3$lx
```

This grabs the third argument to printf (not including the format string itself), which is the fourth argument, which is `rcx` under [64-bit calling conventions in Linux](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI). We use `l` to treat it as 64-bit so we get all of it, and `x` to conveniently print it in hexadecimal.

But after a few tries you will realise there is no consistent difference between the value at `rcx` and the base address of the binary, even if you ignore the last 3 nibbles. Maybe there is something smarter we can do with this value but not that I know of.

So let's look at the stack, which carries the seventh argument onwards in the calling conventions.

```
%11$lx
```

The above gives us another address in the same memory map as the code, and it always seems to be exactly `0x8dd` more than the base. Score!

Now that we know how to calculate the base address, what can we do with it? We can get the address of anything that is part of the executable, including the address of `main`, as well as the GOT entries for libc functions like `printf` and `fgets`.

## Step 2 - Orienting ourselves on the stack

We will want to overwrite the return address on the stack, because thanks to full RELRO we cannot overwrite GOT addresses. Since printf can be made to write precise values at precise memory locations with some `%n` wizardry, we do not need to worry about the stack canary as that does not check the actual return address, but just the data next to it. Using

```
%16$lx
```

We get some stack address. If you look at the stack addresses then you will see it starts with the first few same digits, making it easy to identify. The location of the return address can also be found in your favourite debugger simply by going to the `ret` line just before main returns, and rsp will point to the return address. We are interested in the address of the return address, because that's where we want to write to. If you try subtracting the addresses, you will see that the address at `%16$lx` is `0xd8` more than the address of the return address.

We can combine the above two steps to get both addresses in one go:

```
%11$lx %16$lx
```

What is the ` ` for? To help our scripts separate each number.

## Step 3 - Writing stuff (and buying time)

Hmm we are running out of iterations... wouldn't it be great if we could just keep the loop spinning, or have `main` run again? Well now that we know where the return address is, and we know the PIE offset, we can overwrite the return address on the stack to be `main`'s address! We can easily calculate the address of `main` by adding its offset in the binary to the PIE offset. However, doing this can lead to some annoying side effects which can trigger the [MOVAPS issue in Ubuntu 18.04](https://ropemporium.com/guide.html), and it is quite fragile in general. Instead, we will overwrite the iterator variable, call it `i`, so that the loop keeps going more than three times. This happens to be located `0x134` before the stack address we leaked above. To actually perform the write, we need to organise a few things. Firstly we need to find where our input ends up being on the stack so we can read it back with printf (so we can pass the target address to printf's `%n`). Furthermore, we will be sending null bytes (zero value bytes, `\x00`) which will prematurely terminate printf considering our input, so we need to place those addresses with null bytes after our actual format string. To make sure everything works smoothly, we need to align everything to 8 bytes because that's how big arguments are on 64 bit. Since we will be passing some integers for the padding as well, *and* we want to write as much as possible in a single input, let's pad to 32 bytes, before we send along the address which we will read back.

```
%12$lx                          AAAABBBB
```

Gives us the desired `4242424241414141`, so we can read our own values off the stack.

Now we need to perform the writes. Please see the given script for details, as these lines need to be generated on-the-fly depending on the exact addresses in the instance of the process. In essence we write 16 bits using `%hn` (`h` is for 16 bits basically, "half" of 32 bits integer). Since `%n` write the number of bytes printed, we need to abuse the padding feature which we do with `%x` because it is safe (does not crash like `%s` if invalid address).

## Step 4 - Get real addresses of libc functions

As with most ret2libc attacks, we need to know the base of libc. This changes on every instance of the process due to ASLR. Furthermore we want to find out the libc version on the remote server. Remarkably, this can be done simply by leaking the addresses of two different "things" in libc (usually functions), that are referenced in the given executable.

We do a similar strategy to step 3, in which we read back our own value, This time we use `%s` to read the contents of the memory address "as a string" (meaning null bytes will terminate the read). We will read the Global Offset Table (GOT) values of `fgets` and `printf`. GOT is basically a table of function pointers which resolve at runtime to point to the "real" addresses of functions in other libraries, like libc. When running normally, the program goes to the Procedure Linkage Table (PLT) which then points to to GOT which then finally resolves tot he real address. We want to read the GOT immediately because those addresses are doing to be within the actual libc. We can then calculate the other addresses within libc and jump to those directly.

There are some annoying shenanigans regarding line-buffering that we need to deal with so we can get the result, but we do not want to cause newlines unnecessarily as they terminate the input (fgets), but null characters (in some of our addresses) terminate printf earlier (meaning it missed th newline at the end). I avoided this without "wasting a turn" by using `%c` to read a properly padded newline at the end.

We get two addresses, which we know correspond to fgets and printf. We can throw those into [libc database search](https://libc.blukat.me/) to find the remote libc version. If you are running this on your own machine, you might not get the libc because it is too new. However, if you are running it against the Docker system (exposed on port 1337), then you will get `libc6_2.27-3ubuntu1_amd64`.

Nice. Finally we know everything we need to get a shell. But wait, how exactly will we do this???

## Step 5 - one gadget pwnage

libc conveniently gives us a way of spawning a shell - the exact address for a given libc is easily found with [one\_gadget](https://github.com/david942j/one_gadget). The annoying part is these have constraints.

```
$ one_gadget ubuntulibc.so.6
0x4f2c5 execve("/bin/sh", rsp+0x40, environ)
constraints:
  rsp & 0xf == 0
  rcx == NULL

0x4f322 execve("/bin/sh", rsp+0x40, environ)
constraints:
  [rsp+0x40] == NULL

0x10a38c execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL

```

Since registers are not able to be controlled so easily in our case, I decided to pick `0x10a38c`.
By inspection of the stack, we see that these requiements are already satisfied if we just leave the loop (and hence when `main` returns).


## Step 6 - unleashing the pwn

Simply overwrite the loop counter/iterator variable `i` so that we leave the loop. `main` then performs a return to our one gadget address.

We have a shell on the remote host!
